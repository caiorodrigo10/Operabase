# üîß Guia de Resolu√ß√£o de APIs - Operabase

## üìã Vis√£o Geral

Este documento apresenta a **metodologia comprovada** para diagn√≥stico e resolu√ß√£o de problemas em endpoints da API Operabase, baseada na resolu√ß√£o bem-sucedida dos endpoints de usu√°rios e profissionais.

## üéØ **CASO DE SUCESSO: Usu√°rios e Profissionais**

### Problema Original
```javascript
TypeError: Cannot read properties of undefined (reading 'split')
```

### Status Final
‚úÖ **RESOLVIDO COMPLETAMENTE**
- Endpoints funcionando: `/api/clinic/:id/users/management` e `/api/clinic/:id/professionals`
- Frontend sem erros de JavaScript
- Dados completos com nomes e emails
- Sistema 100% operacional

---

## üîç **METODOLOGIA DE DIAGN√ìSTICO**

### Fase 1: Identifica√ß√£o do Erro

#### 1.1 An√°lise do Erro Frontend
```bash
# ‚úÖ PASSO: Examinar stack trace no console do browser
# OBJETIVO: Identificar linha espec√≠fica e opera√ß√£o que falha

# EXEMPLO DO CASO RESOLVIDO:
# TypeError: Cannot read properties of undefined (reading 'split')
# at index-BNhU-L4t.js:177:80936
```

#### 1.2 Localiza√ß√£o do C√≥digo Problem√°tico
```bash
# ‚úÖ PASSO: Buscar por padr√µes no c√≥digo fonte
grep -r "\.split(" src/
grep -r "\.map(" src/
grep -r "opera√ß√£o_suspeita" src/

# EXEMPLO DO CASO RESOLVIDO:
# src/components/UserManagement.tsx:390
# {user.name.split(' ').map(n => n[0]).join('').toUpperCase()}
```

#### 1.3 Identifica√ß√£o da Origem dos Dados
```bash
# ‚úÖ PASSO: Rastrear de onde v√™m os dados problem√°ticos
# PROCURAR POR: useQuery, fetch, API calls

# EXEMPLO DO CASO RESOLVIDO:
# const { data: users = [] } = useQuery({
#   queryKey: [`/api/clinic/${clinicId}/users/management`],
# });
```

### Fase 2: Verifica√ß√£o dos Dados da API

#### 2.1 Teste Direto do Endpoint
```bash
# ‚úÖ PASSO: Testar endpoint via proxy Vercel
curl -s "https://operabase.vercel.app/api/endpoint" | jq '.'

# EXEMPLO DO CASO RESOLVIDO:
curl -s "https://operabase.vercel.app/api/clinic/1/users/management" | jq '.[].name'
# RESULTADO: null, null, null (problema identificado!)
```

#### 2.2 Teste Direto do Backend
```bash
# ‚úÖ PASSO: Testar endpoint diretamente no AWS
curl -s "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/endpoint" | jq '.'

# OBJETIVO: Verificar se problema est√° no backend ou proxy
```

#### 2.3 An√°lise da Estrutura de Dados
```bash
# ‚úÖ PASSO: Examinar estrutura completa dos dados retornados
curl -s "https://operabase.vercel.app/api/endpoint" | jq '.[0]'

# EXEMPLO DO CASO RESOLVIDO:
# {
#   "id": 11,
#   "clinic_id": 1,
#   "user_id": 6,
#   "name": null,    # ‚Üê PROBLEMA ENCONTRADO
#   "email": null    # ‚Üê PROBLEMA ENCONTRADO
# }
```

### Fase 3: An√°lise Arquitetural

#### 3.1 Mapeamento de Tabelas
```sql
-- ‚úÖ PASSO: Identificar tabelas envolvidas e relacionamentos

-- EXEMPLO DO CASO RESOLVIDO:
-- clinic_users (tabela principal consultada)
clinic_users {
  id: number,
  clinic_id: number,
  user_id: number,        -- ‚Üê FK para users
  role: string,
  permissions: array,
  is_professional: boolean
  -- ‚ùå SEM name, email
}

-- users (tabela com dados necess√°rios)
users {
  id: number,
  name: string,           -- ‚Üê CAMPO NECESS√ÅRIO
  email: string,          -- ‚Üê CAMPO NECESS√ÅRIO
  created_at: timestamp
}
```

#### 3.2 Identifica√ß√£o do Problema Arquitetural
```javascript
// ‚úÖ AN√ÅLISE: Endpoint consultava apenas uma tabela
// ‚ùå PROBLEMA: Dados necess√°rios estavam em tabela relacionada

// EXEMPLO DO CASO RESOLVIDO:
router.get('/clinic/:clinic_id/users/management', async (req, res) => {
  const query = `select=*&clinic_id=eq.${clinic_id}`;
  const clinicUsers = await supabaseQuery(`clinic_users?${query}`);
  //                                       ^^^^^^^^^^^
  //                                       TABELA SEM name/email
  res.json(clinicUsers);
});
```

---

## ‚úÖ **METODOLOGIA DE CORRE√á√ÉO**

### Abordagem: JOIN Manual via M√∫ltiplas Queries

#### Padr√£o Template para Endpoints com Relacionamentos
```javascript
router.get('/api/endpoint-com-relacionamento', async (req, res) => {
  try {
    const { clinic_id } = req.params;
    
    // 1. BUSCAR DADOS DA TABELA PRINCIPAL
    const mainQuery = `select=*&clinic_id=eq.${clinic_id}&is_active=eq.true`;
    const mainRecords = await supabaseQuery(`main_table?${mainQuery}`);
    
    log(`üìä Found ${mainRecords.length} main records`);
    
    // 2. ENRIQUECER COM DADOS RELACIONADOS
    const enrichedRecords = await Promise.all(
      mainRecords.map(async (record) => {
        let relatedData = { 
          name: 'Unknown Entity', 
          email: '',
          // outros campos padr√£o
        };
        
        // 2.1 Buscar dados relacionados se FK existe
        if (record.related_id) {
          try {
            const relatedQuery = `select=name,email,other_fields&id=eq.${record.related_id}`;
            const related = await supabaseQuery(`related_table?${relatedQuery}`);
            
            if (related.length > 0) {
              relatedData = {
                name: related[0].name || 'Unknown Entity',
                email: related[0].email || '',
                // outros campos
              };
            }
          } catch (relatedError) {
            log(`‚ö†Ô∏è Error getting related data for ${record.id}: ${relatedError.message}`);
          }
        }
        
        // 3. COMBINAR DADOS E SANITIZAR
        return {
          ...record,
          // Adicionar campos relacionados
          name: relatedData.name,
          email: relatedData.email,
          // Sanitizar campos array (CR√çTICO!)
          permissions: record.permissions || [],
          tags: record.tags || [],
          categories: record.categories || [],
          // Sanitizar campos string
          description: record.description || '',
          notes: record.notes || ''
        };
      })
    );
    
    log(`‚úÖ Returning ${enrichedRecords.length} enriched records`);
    res.json(enrichedRecords);
    
  } catch (error) {
    log(`‚ùå Error in endpoint: ${error.message}`);
    log(`‚ùå Stack trace: ${error.stack}`);
    res.status(500).json({ 
      error: 'Failed to get records',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

### Regras de Sanitiza√ß√£o Obrigat√≥rias

#### Campos Array
```javascript
// ‚úÖ SEMPRE: Transformar null em array vazio
const sanitized = {
  ...record,
  permissions: record.permissions || [],
  tags: record.tags || [],
  categories: record.categories || [],
  working_days: record.working_days || [],
  specialties: record.specialties || [],
  services: record.services || [],
  payment_methods: record.payment_methods || [],
  lunch_times: record.lunch_times || [],
  business_hours: record.business_hours || []
};
```

#### Campos String
```javascript
// ‚úÖ SEMPRE: Transformar null em string vazia
const sanitized = {
  ...record,
  name: record.name || 'Unknown',
  email: record.email || '',
  description: record.description || '',
  notes: record.notes || '',
  phone: record.phone || ''
};
```

#### Campos Opcionais
```javascript
// ‚úÖ SEMPRE: Manter null para campos verdadeiramente opcionais
const sanitized = {
  ...record,
  avatar_url: record.avatar_url || null,
  last_login: record.last_login || null,
  invited_at: record.invited_at || null
};
```

---

## üß™ **METODOLOGIA DE VALIDA√á√ÉO**

### Fase 1: Valida√ß√£o Backend

#### 1.1 Teste Endpoint Direto
```bash
# ‚úÖ PASSO: Validar resposta do backend AWS
curl -s "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/endpoint" | jq '.'

# ‚úÖ VERIFICAR:
# - Status 200
# - Dados completos
# - Campos n√£o-null onde esperado
# - Arrays n√£o-null
```

#### 1.2 Valida√ß√£o de Campos Cr√≠ticos
```bash
# ‚úÖ PASSO: Verificar campos espec√≠ficos que causavam erro
curl -s "http://backend/api/endpoint" | jq '.[0].campo_critico'

# EXEMPLO DO CASO RESOLVIDO:
curl -s "http://backend/api/clinic/1/users/management" | jq '.[0].name'
# RESULTADO ESPERADO: "Teste2" (n√£o null)
```

### Fase 2: Valida√ß√£o Proxy

#### 2.1 Teste Via Vercel
```bash
# ‚úÖ PASSO: Validar funcionamento end-to-end
curl -s "https://operabase.vercel.app/api/endpoint" | jq '.'

# ‚úÖ VERIFICAR:
# - Mesmo resultado do backend direto
# - Proxy funcionando corretamente
# - Headers corretos
```

### Fase 3: Valida√ß√£o Frontend

#### 3.1 Teste Local
```bash
# ‚úÖ PASSO: Executar frontend local
npm run dev
# Acessar http://localhost:5174

# ‚úÖ VERIFICAR:
# - Console sem erros TypeError
# - Dados carregando corretamente
# - Funcionalidades operacionais
```

#### 3.2 Teste de Funcionalidades
```bash
# ‚úÖ PASSO: Testar funcionalidades espec√≠ficas que falhavam

# EXEMPLO DO CASO RESOLVIDO:
# - Verificar se avatares dos usu√°rios aparecem
# - Verificar se nomes s√£o exibidos
# - Verificar se n√£o h√° erros de split()
```

---

## üìã **CHECKLIST DE VALIDA√á√ÉO COMPLETA**

### ‚úÖ Antes de Implementar
- [ ] Identificar todas as tabelas envolvidas
- [ ] Mapear relacionamentos (foreign keys)
- [ ] Verificar quais campos s√£o necess√°rios no frontend
- [ ] Identificar campos que podem ser null
- [ ] Verificar opera√ß√µes JavaScript que podem falhar (split, map, etc.)

### ‚úÖ Durante Implementa√ß√£o
- [ ] Implementar JOIN manual via m√∫ltiplas queries
- [ ] Sanitizar TODOS os campos array (null ‚Üí [])
- [ ] Sanitizar campos string cr√≠ticos (null ‚Üí '')
- [ ] Adicionar tratamento de erro detalhado
- [ ] Incluir logs de debug com contexto
- [ ] Usar try/catch para queries relacionadas

### ‚úÖ Valida√ß√£o P√≥s-Implementa√ß√£o
- [ ] Testar endpoint direto no backend AWS
- [ ] Testar via proxy Vercel
- [ ] Verificar no frontend local (sem erros no console)
- [ ] Validar com dados reais da produ√ß√£o
- [ ] Testar casos extremos (dados faltando, relacionamentos quebrados)
- [ ] Verificar performance (m√∫ltiplas queries podem ser lentas)

### ‚úÖ Documenta√ß√£o
- [ ] Documentar mudan√ßas no c√≥digo
- [ ] Atualizar lista de endpoints dispon√≠veis
- [ ] Registrar aprendizados espec√≠ficos
- [ ] Criar testes automatizados (se aplic√°vel)

---

## üéØ **APLICA√á√ÉO PARA PR√ìXIMAS FUNCIONALIDADES**

### Funcionalidades Pendentes e Padr√µes Esperados

#### 1. **Conversations**
```javascript
// ESPERADO: JOIN com contacts para nomes dos pacientes
// PADR√ÉO: conversation.contact_id ‚Üí contacts.name
// SANITIZA√á√ÉO: messages: [], attachments: []
```

#### 2. **Medical Records**  
```javascript
// ESPERADO: JOIN com contacts e users
// PADR√ÉO: record.contact_id ‚Üí contacts.name
// PADR√ÉO: record.professional_id ‚Üí users.name
// SANITIZA√á√ÉO: symptoms: [], medications: []
```

#### 3. **Pipeline**
```javascript
// ESPERADO: JOIN com contacts para oportunidades
// PADR√ÉO: opportunity.contact_id ‚Üí contacts.name
// SANITIZA√á√ÉO: tags: [], custom_fields: []
```

#### 4. **Analytics**
```javascript
// ESPERADO: Agrega√ß√µes com JOINs
// PADR√ÉO: M√∫ltiplas queries para diferentes m√©tricas
// SANITIZA√á√ÉO: Todos os arrays de dados
```

#### 5. **Settings**
```javascript
// ESPERADO: Relacionamentos com users para configura√ß√µes
// PADR√ÉO: setting.user_id ‚Üí users.name
// SANITIZA√á√ÉO: permissions: [], preferences: []
```

---

## üöÄ **RESULTADOS COMPROVADOS**

### Antes da Aplica√ß√£o da Metodologia
```json
// ‚ùå DADOS PROBLEM√ÅTICOS
{
  "id": 11,
  "name": null,           // ‚Üê Causava erro split()
  "email": null,
  "permissions": null     // ‚Üê Causava erro map()
}
```

### Depois da Aplica√ß√£o da Metodologia
```json
// ‚úÖ DADOS CORRIGIDOS
{
  "id": 11,
  "name": "Teste2",              // ‚Üê Nome real do usu√°rio
  "email": "teste2@gmail.com",   // ‚Üê Email real do usu√°rio
  "permissions": []              // ‚Üê Array vazio (n√£o null)
}
```

### Impacto no Frontend
```typescript
// ‚úÖ C√ìDIGO FUNCIONANDO
{user.name.split(' ').map(n => n[0]).join('').toUpperCase()}
//     ^^^^
//     "Teste2" ‚Üí ["Teste2"] ‚Üí ["T"] ‚Üí "T"
```

---

## üìö **LI√á√ïES CR√çTICAS APRENDIDAS**

### 1. **Diagn√≥stico Sistem√°tico √© Fundamental**
- ‚úÖ Sempre come√ßar pelo erro espec√≠fico no frontend
- ‚úÖ Rastrear at√© a origem dos dados na API
- ‚úÖ Verificar estrutura das tabelas no banco de dados
- ‚ùå Nunca assumir que o problema est√° onde parece estar

### 2. **Supabase REST API Limita√ß√µes**
- ‚úÖ N√£o faz JOINs autom√°ticos entre tabelas
- ‚úÖ Implementar JOIN manual via m√∫ltiplas queries
- ‚úÖ Sempre incluir fallbacks para dados n√£o encontrados
- ‚ùå N√£o assumir que dados relacionados estar√£o dispon√≠veis

### 3. **Sanitiza√ß√£o √© Obrigat√≥ria**
- ‚úÖ Frontend JavaScript n√£o tolera null em opera√ß√µes de array
- ‚úÖ Sempre transformar null em [] para campos array
- ‚úÖ Sempre transformar null em string vazia para campos string cr√≠ticos
- ‚ùå Nunca retornar null para campos que ser√£o processados no frontend

### 4. **Valida√ß√£o End-to-End √© Essencial**
- ‚úÖ Testar backend direto (AWS)
- ‚úÖ Testar via proxy (Vercel)
- ‚úÖ Testar no frontend (local)
- ‚úÖ Validar com dados reais de produ√ß√£o
- ‚ùå Nunca assumir que funcionou sem testar todos os n√≠veis

---

## üîÑ **PR√ìXIMOS PASSOS**

### Aplicar Esta Metodologia Para:

1. **Conversations** ‚Üí Resolver exibi√ß√£o de nomes de contatos
2. **Medical Records** ‚Üí Resolver relacionamentos com pacientes e profissionais  
3. **Pipeline** ‚Üí Resolver dados de oportunidades e contatos
4. **Analytics** ‚Üí Resolver agrega√ß√µes e relat√≥rios
5. **Settings** ‚Üí Resolver configura√ß√µes de usu√°rios

### Cada funcionalidade deve seguir:
1. **Diagn√≥stico** usando esta metodologia
2. **Corre√ß√£o** usando os padr√µes estabelecidos
3. **Valida√ß√£o** usando o checklist completo
4. **Documenta√ß√£o** dos aprendizados espec√≠ficos

---

**Este guia garante que todas as futuras corre√ß√µes de API sigam um padr√£o comprovado e eficiente, evitando retrabalho e garantindo qualidade.** 