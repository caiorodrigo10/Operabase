# Guia de Integra√ß√£o Banco de Dados - Frontend

## üìã Vis√£o Geral

Este documento consolida os aprendizados pr√°ticos sobre como vincular corretamente o banco de dados com o frontend, baseado na resolu√ß√£o de problemas reais no sistema de consultas da Operabase.

## üéØ Problema Principal Resolvido

### ‚ùå **Problema Original**
Consultas apareciam e desapareciam no calend√°rio devido a problemas de timing e vincula√ß√£o incorreta entre:
- Tabela `appointments` (consultas)
- Tabela `clinic_users` (profissionais)
- Frontend (sele√ß√£o de profissionais)

### ‚úÖ **Solu√ß√£o Implementada**
Sistema multi-tenant robusto com vincula√ß√£o correta de IDs e carregamento coordenado.

---

## üóÑÔ∏è Estrutura do Banco de Dados

### Tabelas Principais

#### `appointments` (Consultas)
```sql
appointments {
  id: number,
  clinic_id: number,      -- FK para clinics
  user_id: number,        -- FK para users (PROFISSIONAL)
  contact_id: number,     -- FK para contacts (PACIENTE)
  scheduled_date: timestamp,
  status: string,
  doctor_name: string,    -- Campo redundante (pode ser null)
  notes: text
}
```

#### `clinic_users` (Relacionamento Cl√≠nica-Usu√°rio)
```sql
clinic_users {
  id: number,             -- clinic_user_id (INTERNO)
  clinic_id: number,      -- FK para clinics
  user_id: number,        -- FK para users (CHAVE REAL)
  is_professional: boolean,
  is_active: boolean,
  role: string,
  permissions: array
}
```

#### `users` (Dados dos Usu√°rios)
```sql
users {
  id: number,             -- user_id (CHAVE PRIM√ÅRIA)
  name: string,
  email: string,
  created_at: timestamp
}
```

### üîë **REGRA FUNDAMENTAL**
**SEMPRE usar `user_id` para relacionamentos, NUNCA `clinic_user_id`**

---

## üö® Problemas Identificados e Solu√ß√µes

### 1. **Confus√£o Entre IDs**

#### ‚ùå **Erro Comum**
```javascript
// ERRADO: Usar clinic_user_id para filtrar consultas
const selectedProfessional = 2; // clinic_user_id
const filteredAppointments = appointments.filter(apt => 
  apt.user_id === selectedProfessional // ‚Üê NUNCA VAI BATER!
);
```

#### ‚úÖ **Corre√ß√£o**
```javascript
// CORRETO: Usar user_id consistentemente
const selectedProfessional = 4; // user_id
const filteredAppointments = appointments.filter(apt => 
  apt.user_id === selectedProfessional // ‚Üê AGORA FUNCIONA!
);
```

#### üìä **Mapeamento Real**
```
clinic_users.id=2 ‚Üí clinic_users.user_id=4 ‚Üí users.id=4 (Caio Rodrigo)
appointments.user_id=4 ‚Üí 63 consultas

PROBLEMA: selectedProfessional=2 (clinic_user_id)
SOLU√á√ÉO: selectedProfessional=4 (user_id)
```

### 2. **Query Sem queryFn**

#### ‚ùå **Erro Comum**
```javascript
// ERRADO: Query sem queryFn nunca executa
const { data: clinicUsers = [] } = useQuery({
  queryKey: QUERY_KEYS.CLINIC_USERS(1),
  staleTime: 5 * 60 * 1000,
  // ‚Üê FALTANDO queryFn!
});
// Resultado: clinicUsers sempre = []
```

#### ‚úÖ **Corre√ß√£o**
```javascript
// CORRETO: Query com queryFn completo
const { data: clinicUsers = [] } = useQuery({
  queryKey: QUERY_KEYS.CLINIC_USERS(1),
  queryFn: async () => {
    const url = buildApiUrl('/api/clinic/1/users/management');
    const response = await fetch(url, { /* headers */ });
    return response.json();
  },
  staleTime: 5 * 60 * 1000,
});
```

### 3. **Timing de Carregamento**

#### ‚ùå **Problema de Timing**
```javascript
// ERRADO: Carregamento sequencial causa flicker
1. P√°gina carrega com selectedProfessional = null
2. Appointments carregam e mostram TODAS as consultas
3. clinicUsers carrega (2-3 segundos depois)
4. useEffect auto-seleciona profissional
5. Consultas s√£o filtradas ‚Üí outras desaparecem
```

#### ‚úÖ **Solu√ß√£o: Carregamento Coordenado**
```javascript
// CORRETO: Aguardar dados cr√≠ticos antes de renderizar
const isInitialDataLoading = appointmentsLoading || !clinicUsers.length;

if (isInitialDataLoading) {
  return <LoadingSpinner />;
}

// S√≥ renderiza quando TODOS os dados est√£o prontos
```

### 4. **Auto-sele√ß√£o de Profissional**

#### ‚ùå **Erro de Condicionamento**
```javascript
// ERRADO: useEffect muito restritivo
useEffect(() => {
  if (clinicUsers.length > 0 && selectedProfessional === null && currentUserEmail) {
    // ‚Üê S√≥ executa se tiver email
  }
}, [clinicUsers.length, selectedProfessional, currentUserEmail]);
```

#### ‚úÖ **Corre√ß√£o: Fallback Robusto**
```javascript
// CORRETO: useEffect com m√∫ltiplos fallbacks
useEffect(() => {
  if (clinicUsers.length > 0 && selectedProfessional === null) {
    // 1¬∫: Tentar usu√°rio atual (se profissional)
    let defaultSelection = getDefaultProfessionalSelection(clinicUsers, currentUserEmail || '', clinicId);
    
    // 2¬∫: Fallback para primeiro profissional dispon√≠vel
    if (!defaultSelection) {
      const firstProfessional = clinicUsers.find(user => 
        user.is_professional && user.is_active
      );
      if (firstProfessional) {
        defaultSelection = firstProfessional.user_id; // ‚Üê user_id!
      }
    }
    
    if (defaultSelection) {
      setSelectedProfessional(defaultSelection);
    }
  }
}, [clinicUsers.length, selectedProfessional, currentUserEmail]);
```

---

## üèóÔ∏è Arquitetura Multi-Tenant

### Fun√ß√µes Utilit√°rias

#### 1. **Obter IDs V√°lidos (Incluindo √ìrf√£os)**
```javascript
const getValidUserIds = (clinicId: number, clinicUsers: any[], appointments: any[] = []): number[] => {
  // IDs da tabela clinic_users
  const clinicUserIds = clinicUsers
    .filter(user => user.clinic_id === clinicId && user.is_active)
    .map(user => user.user_id); // ‚Üê user_id, n√£o id!
  
  // IDs das consultas (para incluir "√≥rf√£os")
  const appointmentUserIds = appointments
    .filter(appointment => appointment.clinic_id === clinicId && appointment.user_id)
    .map(appointment => appointment.user_id);
  
  // Combinar e remover duplicatas
  return [...new Set([...clinicUserIds, ...appointmentUserIds])];
};
```

#### 2. **Sele√ß√£o Inteligente de Profissional**
```javascript
const getDefaultProfessionalSelection = (
  clinicUsers: any[], 
  currentUserEmail: string,
  clinicId: number
): number | null => {
  if (!clinicUsers.length) return null;
  
  // 1. Prioridade: usu√°rio atual se for profissional
  if (currentUserEmail) {
    const currentUser = clinicUsers.find(u => 
      u.email === currentUserEmail && u.is_professional
    );
    if (currentUser) {
      return currentUser.user_id; // ‚Üê SEMPRE user_id!
    }
  }
  
  // 2. Fallback: primeiro profissional ativo
  const firstProfessional = clinicUsers.find(u => 
    u.clinic_id === clinicId && u.is_professional && u.is_active
  );
  if (firstProfessional) {
    return firstProfessional.user_id; // ‚Üê SEMPRE user_id!
  }
  
  return null;
};
```

#### 3. **Cache Persistente por Cl√≠nica**
```javascript
// Salvar sele√ß√£o
const saveProfessionalSelection = (professionalId: number, clinicId: number): void => {
  localStorage.setItem(`selected_professional_${clinicId}`, professionalId.toString());
};

// Recuperar sele√ß√£o
const getCachedProfessionalSelection = (clinicId: number): number | null => {
  const cached = localStorage.getItem(`selected_professional_${clinicId}`);
  return cached ? parseInt(cached, 10) : null;
};
```

---

## üîÑ Padr√µes de TanStack Query

### 1. **Query Structure Padr√£o**
```javascript
const { data: appointments = [], isLoading: appointmentsLoading } = useQuery({
  queryKey: QUERY_KEYS.APPOINTMENTS(clinicId),
  queryFn: async () => {
    const url = buildApiUrl(`/api/appointments?clinic_id=${clinicId}`);
    const response = await fetch(url, {
      headers: await getAuthHeaders()
    });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return response.json();
  },
  staleTime: 2 * 60 * 1000,    // 2 minutos
  gcTime: 10 * 60 * 1000,      // 10 minutos
  refetchOnWindowFocus: false,
  enabled: !!clinicId,         // S√≥ executa se tiver clinicId
});
```

### 2. **Invalida√ß√£o Coordenada**
```javascript
// Invalidar todas as queries relacionadas
const invalidateAppointmentQueries = async (queryClient: QueryClient, clinicId: number) => {
  await Promise.all([
    queryClient.invalidateQueries({ queryKey: ['appointments', clinicId] }),
    queryClient.invalidateQueries({ queryKey: ['clinic-users', clinicId] }),
    queryClient.invalidateQueries({ queryKey: ['contacts', clinicId] })
  ]);
};
```

### 3. **Loading States Coordenados**
```javascript
// Aguardar TODOS os dados cr√≠ticos
const isInitialDataLoading = appointmentsLoading || !clinicUsers.length || clinicConfigLoading;

// Loading com feedback detalhado
if (isInitialDataLoading) {
  return (
    <LoadingSpinner>
      <div>‚Ä¢ {appointmentsLoading ? '‚è≥' : '‚úÖ'} Consultas</div>
      <div>‚Ä¢ {!clinicUsers.length ? '‚è≥' : '‚úÖ'} Profissionais</div>
      <div>‚Ä¢ {clinicConfigLoading ? '‚è≥' : '‚úÖ'} Configura√ß√µes</div>
    </LoadingSpinner>
  );
}
```

---

## üéØ Componentes Frontend

### 1. **Sele√ß√£o de Profissionais**
```javascript
// Bot√µes de profissionais usando user_id
{clinicUsers
  .filter(user => user.is_professional === true)
  .map(professional => {
    const isSelected = selectedProfessional === professional.user_id; // ‚Üê user_id!
    
    return (
      <button
        key={professional.user_id}                          // ‚Üê user_id!
        onClick={() => selectProfessional(professional.user_id)} // ‚Üê user_id!
        className={isSelected ? 'selected' : 'unselected'}
      >
        {professional.name}
      </button>
    );
  })
}
```

### 2. **Filtragem de Consultas**
```javascript
// Filtrar consultas pelo profissional selecionado
const filteredAppointments = useMemo(() => {
  if (!selectedProfessional) return validAppointments;
  
  return validAppointments.filter(appointment => 
    appointment.user_id === selectedProfessional // ‚Üê user_id sempre!
  );
}, [validAppointments, selectedProfessional]);
```

---

## üö® Armadilhas Comuns

### 1. **‚ùå Usar clinic_user_id em vez de user_id**
```javascript
// NUNCA FA√áA ISSO
const selectedProfessional = professional.id; // ‚Üê clinic_user_id
const filteredAppointments = appointments.filter(apt => 
  apt.user_id === selectedProfessional // ‚Üê Nunca vai bater!
);
```

### 2. **‚ùå Query sem queryFn**
```javascript
// NUNCA FA√áA ISSO
const { data } = useQuery({
  queryKey: ['data'],
  // ‚Üê Sem queryFn = nunca executa
});
```

### 3. **‚ùå useEffect muito restritivo**
```javascript
// NUNCA FA√áA ISSO
useEffect(() => {
  if (data && user && email && condition1 && condition2) {
    // ‚Üê Muitas condi√ß√µes = nunca executa
  }
}, [data, user, email, condition1, condition2]);
```

### 4. **‚ùå Renderizar antes dos dados**
```javascript
// NUNCA FA√áA ISSO
// Renderiza imediatamente, depois os dados chegam
return (
  <div>
    {appointments.map(apt => <AppointmentCard key={apt.id} appointment={apt} />)}
  </div>
);
```

---

## ‚úÖ Melhores Pr√°ticas

### 1. **üîë Consist√™ncia de IDs**
- **SEMPRE** use `user_id` para relacionamentos
- **NUNCA** use `clinic_user_id` para filtros
- **SEMPRE** documente qual ID est√° sendo usado

### 2. **‚è±Ô∏è Carregamento Coordenado**
```javascript
// Aguarde TODOS os dados cr√≠ticos
const isReady = !appointmentsLoading && clinicUsers.length > 0 && !configLoading;

if (!isReady) {
  return <LoadingSpinner />;
}
```

### 3. **üéØ Auto-sele√ß√£o Robusta**
```javascript
// M√∫ltiplos fallbacks para sempre ter algo selecionado
useEffect(() => {
  if (hasData && !hasSelection) {
    const selection = 
      getUserSelection() ||           // 1¬∫: Usu√°rio atual
      getCachedSelection() ||         // 2¬∫: Cache
      getFirstAvailable() ||          // 3¬∫: Primeiro dispon√≠vel
      getDefaultFallback();           // 4¬∫: Fallback final
    
    if (selection) setSelection(selection);
  }
}, [hasData, hasSelection]);
```

### 4. **üìù Logging Detalhado**
```javascript
// Logs para debug de problemas de vincula√ß√£o
console.log('üîß Valid user IDs calculation:', {
  clinicId,
  clinicUserIds,      // IDs da tabela clinic_users
  appointmentUserIds, // IDs das consultas
  allValidUserIds     // Uni√£o final
});

console.log('üéØ Final filtered appointments:', filteredAppointments.length);
```

### 5. **üß™ Valida√ß√£o de Dados**
```javascript
// Sempre validar estrutura dos dados
const validateUserData = (users: any[]) => {
  return users.every(user => 
    user.user_id &&           // Tem user_id
    user.clinic_id &&         // Tem clinic_id
    typeof user.is_professional === 'boolean' // is_professional √© boolean
  );
};
```

---

## üìä Debugging e Monitoramento

### 1. **Logs Estruturados**
```javascript
// Log detalhado para debug
console.log('üîç DETAILED APPOINTMENT DEBUG:');
appointments.forEach(apt => {
  console.log(`   ID ${apt.id}: ${apt.contact_name || 'null'} - User ${apt.user_id}`);
  console.log(`   üìÖ Date: ${apt.scheduled_date}`);
  console.log(`   üìç Status: ${apt.status}`);
});
```

### 2. **M√©tricas de Performance**
```javascript
// Monitorar performance das queries
const startTime = performance.now();
const appointments = await fetchAppointments();
const endTime = performance.now();
console.log(`‚è±Ô∏è Appointments loaded in ${endTime - startTime}ms`);
```

### 3. **Valida√ß√£o de Integridade**
```javascript
// Verificar integridade dos dados
const orphanedAppointments = appointments.filter(apt => 
  !clinicUsers.some(user => user.user_id === apt.user_id)
);

if (orphanedAppointments.length > 0) {
  console.warn('üö® Found orphaned appointments:', orphanedAppointments);
}
```

---

## üéØ Checklist de Implementa√ß√£o

### ‚úÖ **Backend**
- [ ] Endpoint retorna `user_id` consistentemente
- [ ] JOIN manual implementado para dados relacionados
- [ ] Sanitiza√ß√£o de campos null ‚Üí arrays vazios
- [ ] Logs detalhados para debug
- [ ] Tratamento de erro robusto

### ‚úÖ **Frontend**
- [ ] TanStack Query com `queryFn` completo
- [ ] Loading coordenado de dados cr√≠ticos
- [ ] Auto-sele√ß√£o com m√∫ltiplos fallbacks
- [ ] Uso consistente de `user_id`
- [ ] Cache persistente por cl√≠nica

### ‚úÖ **Integra√ß√£o**
- [ ] Mapeamento correto de IDs documentado
- [ ] Logs de debug implementados
- [ ] Valida√ß√£o de integridade de dados
- [ ] Tratamento de casos edge
- [ ] Testes com dados reais

---

## üöÄ Resultados Comprovados

### Antes da Corre√ß√£o
```
‚ùå Consultas apareciam e desapareciam
‚ùå selectedProfessional = clinic_user_id (2)
‚ùå appointments.user_id = 4
‚ùå Filtro nunca funcionava
‚ùå Final filtered appointments: 0
```

### Depois da Corre√ß√£o
```
‚úÖ Consultas aparecem consistentemente
‚úÖ selectedProfessional = user_id (4)
‚úÖ appointments.user_id = 4
‚úÖ Filtro funciona perfeitamente
‚úÖ Final filtered appointments: 63
```

---

## üî¨ Valida√ß√µes Implementadas e Testadas

### 1. **Sistema WhatsApp Numbers**
```javascript
// Problema: Array vazio no frontend
// Causa: Endpoint n√£o implementado corretamente
// Solu√ß√£o: Logs detalhados + endpoint validado

// Backend validado:
‚úÖ Dados no Supabase: 1 n√∫mero ativo (551150391104)
‚úÖ Endpoint funcionando: GET /api/whatsapp/numbers
‚úÖ Response JSON: Array com 1 item

// Frontend validado:
‚úÖ Logs implementados: [WhatsAppManager][fetch] pattern
‚úÖ Estado atualizado: setWhatsappNumbers(data)
‚úÖ Renderiza√ß√£o: WhatsAppNumberCard exibido
```

### 2. **Sistema de Conversas**
```javascript
// Problema: Endpoints 404
// Causa: Rotas n√£o registradas
// Solu√ß√£o: Registro correto + timezone fix

// Backend validado:
‚úÖ Rotas registradas: conversations.routes.js
‚úÖ Dados no Supabase: 5 conversas, m√∫ltiplas mensagens
‚úÖ Timezone Bras√≠lia: getBrasiliaTimestamp() implementado

// Frontend validado:
‚úÖ Conversas carregando: useConversations hook
‚úÖ Mensagens exibindo: MessageBubble component
‚úÖ Hor√°rio correto: 1:43 AM (n√£o 4:43 AM)
```

### 3. **Metodologia de Debugging Validada**
```
Processo comprovado eficaz:

1. Identificar sintoma
   ‚úÖ WhatsApp array vazio
   ‚úÖ Conversas 404

2. Verificar fonte de dados
   ‚úÖ MCP Supabase: dados existem
   ‚úÖ SQL queries: registros confirmados

3. Testar endpoint isolado
   ‚úÖ curl localhost:3000/api/whatsapp/numbers
   ‚úÖ Response JSON v√°lido

4. Adicionar logs frontend
   ‚úÖ [Component][operation] pattern
   ‚úÖ Logs de fetch, parse, setState

5. Rastrear fluxo completo
   ‚úÖ Database ‚Üí Backend ‚Üí Frontend ‚Üí UI
   ‚úÖ Cada etapa logada e validada

6. Implementar corre√ß√£o
   ‚úÖ Endpoint implementado
   ‚úÖ Rotas registradas
   ‚úÖ Logs mantidos para monitoramento

7. Validar funcionamento
   ‚úÖ Dados aparecendo no frontend
   ‚úÖ Estados atualizados corretamente
   ‚úÖ UI renderizando como esperado

8. Documentar solu√ß√£o
   ‚úÖ Relat√≥rio de valida√ß√£o criado
   ‚úÖ Documenta√ß√£o atualizada
   ‚úÖ Processo replic√°vel
```

### 4. **Padr√µes de Logs Validados**
```javascript
// Padr√£o implementado e funcionando:

// Backend
console.log('üîç Buscando dados para clinic_id:', clinic_id);
console.log('‚úÖ Dados encontrados:', data?.length || 0);
console.log('‚ùå Erro ao buscar dados:', error);

// Frontend
console.log('[Component][operation] Iniciando...');
console.log('[Component][operation] Dados recebidos:', data);
console.log('[Component][operation] Estado atualizado:', state);

// Resultado: Debugging eficaz e rastreabilidade completa
```

---

## üìö Recursos Adicionais

### Documenta√ß√£o Relacionada
- `docs/BACKEND-ARCHITECTURE.md` - Arquitetura do backend
- `docs/FRONTEND-ARCHITECTURE.md` - Arquitetura do frontend
- `docs/FRONTEND-BACKEND-VALIDATION-REPORT.md` - Relat√≥rio completo de valida√ß√µes
- `docs/API-RESOLUTION-GUIDE.md` - Guia de resolu√ß√£o de APIs

### Ferramentas de Debug Validadas
- ‚úÖ React DevTools - Para estado dos componentes
- ‚úÖ TanStack Query DevTools - Para cache e queries
- ‚úÖ Supabase MCP Tools - Para valida√ß√£o de dados
- ‚úÖ Browser Network Tab - Para requests HTTP
- ‚úÖ Console Logs Estruturados - Para fluxo de dados

### Comandos de Valida√ß√£o
```bash
# Testar endpoints diretamente
curl -s http://localhost:3000/api/whatsapp/numbers | jq
curl -s http://localhost:3000/api/conversations-simple?clinic_id=1 | jq

# Verificar dados no Supabase (via MCP)
# SELECT * FROM whatsapp_numbers WHERE clinic_id = 1;
# SELECT * FROM conversations WHERE clinic_id = 1;

# Monitorar logs em tempo real
npm run dev:railway | grep "üîç\|‚úÖ\|‚ùå"
```

---

*Documenta√ß√£o criada em: Janeiro 2025*
*Baseada em problemas reais resolvidos no projeto Operabase*
*Atualizada com valida√ß√µes implementadas*
*Status: ‚úÖ Testado e Validado em Produ√ß√£o* 