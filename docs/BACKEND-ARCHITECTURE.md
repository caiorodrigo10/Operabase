# Arquitetura do Backend - Operabase

## üìã Vis√£o Geral

Este documento descreve a arquitetura completa do backend da Operabase, um sistema de gest√£o para cl√≠nicas m√©dicas constru√≠do com **Express.js**, **Supabase PostgreSQL**, **Redis Cache** e **arquitetura multi-tenant** com isolamento completo entre cl√≠nicas.

## üåê Conectividade Frontend-Backend

### Arquitetura de Deploy H√≠brida
O sistema utiliza uma **arquitetura h√≠brida de deploy** para resolver problemas de conectividade entre frontend e backend:

- **Frontend**: Vercel (HTTPS) - `https://operabase.vercel.app`
- **Backend**: AWS Elastic Beanstalk (HTTP) - `http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com`

### Problema Resolvido: Mixed Content Error

#### üö® Problema Original
O frontend (HTTPS) n√£o conseguia fazer requisi√ß√µes diretas para o backend (HTTP) devido ao **Mixed Content Error**:

```javascript
// ‚ùå ERRO: HTTPS ‚Üí HTTP bloqueado pelo navegador
fetch('http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/appointments')
// SecurityError: Mixed Content: The page was loaded over HTTPS, but requested an insecure HTTP resource
```

#### ‚úÖ Solu√ß√£o Implementada: Proxy HTTPS
Cria√ß√£o de **proxies HTTPS no Vercel** para rotear requisi√ß√µes de forma segura:

```javascript
// ‚úÖ SOLU√á√ÉO: HTTPS ‚Üí HTTPS Proxy ‚Üí HTTP Backend
fetch('/api/appointments') // Roteado via proxy Vercel
```

### Implementa√ß√£o do Sistema de Proxy

#### 1. Proxy Gen√©rico (`api/[...path].js`)
```javascript
// api/[...path].js - Proxy universal para todas as rotas API
export default async function handler(req, res) {
  const { path } = req.query;
  const apiPath = Array.isArray(path) ? path.join('/') : path;
  
  const backendUrl = `http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/${apiPath}`;
  
  try {
    const response = await fetch(backendUrl, {
      method: req.method,
      headers: {
        'Content-Type': 'application/json',
        ...req.headers
      },
      body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
    });

    const data = await response.json();
    res.status(response.status).json(data);
  } catch (error) {
    res.status(500).json({ error: 'Proxy error', details: error.message });
  }
}
```

#### 2. Proxy Espec√≠fico para Appointments (`api/appointments.js`)
```javascript
// api/appointments.js - Proxy otimizado para appointments
export default async function handler(req, res) {
  const queryString = new URLSearchParams(req.query).toString();
  const backendUrl = `http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/appointments?${queryString}`;
  
  try {
    const response = await fetch(backendUrl);
    const appointments = await response.json();
    
    res.status(200).json(appointments);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch appointments' });
  }
}
```

#### 3. Proxy Espec√≠fico para Contacts (`api/contacts.js`)
```javascript
// api/contacts.js - Proxy otimizado para contacts
export default async function handler(req, res) {
  const queryString = new URLSearchParams(req.query).toString();
  const backendUrl = `http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/contacts?${queryString}`;
  
  try {
    const response = await fetch(backendUrl);
    const contacts = await response.json();
    
    res.status(200).json(contacts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch contacts' });
  }
}
```

### Configura√ß√£o do Frontend

#### Fun√ß√£o `buildApiUrl()` Otimizada
```typescript
// src/lib/api.ts - L√≥gica de roteamento inteligente
function buildApiUrl(endpoint: string): string {
  // Desenvolvimento: usar proxy do Vite
  if (import.meta.env.DEV) {
    return `/api${endpoint}`;
  }
  
  // Produ√ß√£o: SEMPRE usar proxy do Vercel (ignora VITE_API_URL)
  // Isso previne Mixed Content Error for√ßando HTTPS
  return `/api${endpoint}`;
}

// Exemplo de uso
export async function fetchAppointments(clinicId: number) {
  const response = await fetch(buildApiUrl(`/appointments?clinic_id=${clinicId}`));
  return response.json();
}

export async function fetchContacts(clinicId: number) {
  const response = await fetch(buildApiUrl(`/contacts?clinic_id=${clinicId}`));
  return response.json();
}
```

#### Configura√ß√£o Vite (Desenvolvimento)
```typescript
// vite.config.ts - Proxy para desenvolvimento local
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false
      }
    }
  }
});
```

#### Configura√ß√£o Vercel (Produ√ß√£o)
```json
// vercel.json - Configura√ß√£o simplificada para SPA
{
  "rewrites": [
    {
      "source": "/((?!api/).*)",
      "destination": "/index.html"
    }
  ]
}
```

### Corre√ß√£o do Backend: Production Server

#### Problema Identificado: Dual Architecture
O sistema tinha **duas implementa√ß√µes de servidor**:

1. **Sistema de Domains** (`server/domains/`) - N√£o estava sendo usado em produ√ß√£o
2. **Production Server** (`server/production-server.js`) - Servidor real em produ√ß√£o

#### Corre√ß√£o Aplicada: Contacts Endpoint
```javascript
// server/production-server.js - Corre√ß√£o do endpoint de contacts

// ‚ùå ANTES: Query malformada causava erro 400
app.get('/api/contacts', async (req, res) => {
  try {
    let query = `select=*&clinic_id=eq.${clinic_id}`;
    if (status) query += `&status=eq.${status}`;
    if (search) query += `&name=ilike.*${search}*`;
    query += '&order=created_at.desc'; // ‚Üê ERRO: Campo inexistente
    
    const contacts = await supabaseQuery(`contacts?${query}`);
    res.json(contacts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get contacts' });
  }
});

// ‚úÖ DEPOIS: Query corrigida funciona perfeitamente
app.get('/api/contacts', async (req, res) => {
  try {
    let query = `select=*&clinic_id=eq.${clinic_id}`;
    if (status) query += `&status=eq.${status}`;
    if (search) query += `&name=ilike.*${search}*`;
    // REMOVIDO: order=created_at.desc (campo n√£o existe na tabela)
    
    const contacts = await supabaseQuery(`contacts?${query}`);
    res.json(contacts);
  } catch (error) {
    res.status(500).json({ error: 'Failed to get contacts' });
  }
});
```

## üîß **APRENDIZADOS CR√çTICOS: Resolu√ß√£o de Endpoints Usu√°rios e Profissionais**

### üìä **Problema Diagnosticado**

#### Erro Frontend
```javascript
TypeError: Cannot read properties of undefined (reading 'split')
    at index-BNhU-L4t.js:177:80936
    at Array.map (<anonymous>)
    at HL (index-BNhU-L4t.js:177:80900)
```

#### C√≥digo Frontend Problem√°tico
```typescript
// src/components/UserManagement.tsx - Linha 390
{user.name.split(' ').map(n => n[0]).join('').toUpperCase()}
//     ^^^^ 
//     ERRO: user.name era null, causando falha no split()
```

### üîç **Metodologia de Diagn√≥stico**

#### 1. **Identifica√ß√£o da Origem do Erro**
```bash
# ‚úÖ M√âTODO: Buscar por .split( no c√≥digo
grep -r "\.split(" src/
# RESULTADO: Encontrou UserManagement.tsx usando user.name.split()
```

#### 2. **Verifica√ß√£o dos Dados da API**
```bash
# ‚úÖ M√âTODO: Testar endpoint diretamente
curl -s "https://operabase.vercel.app/api/clinic/1/users/management" | jq '.[].name'
# RESULTADO: Todos retornavam null
```

#### 3. **An√°lise da Estrutura de Dados**
```bash
# ‚úÖ M√âTODO: Examinar estrutura completa dos dados
curl -s "https://operabase.vercel.app/api/clinic/1/users/management" | jq '.[0]'
# RESULTADO: Dados vinham da tabela clinic_users (sem name/email)
```

### üéØ **Causa Raiz Identificada**

#### Problema Arquitetural
```javascript
// ‚ùå ENDPOINT INCORRETO: Retornava apenas dados de clinic_users
router.get('/clinic/:clinic_id/users/management', async (req, res) => {
  const query = `select=*&clinic_id=eq.${clinic_id}`;
  const clinicUsers = await supabaseQuery(`clinic_users?${query}`);
  //                                       ^^^^^^^^^^^
  //                                       TABELA SEM name/email
  res.json(clinicUsers);
});
```

#### Schema das Tabelas
```sql
-- clinic_users: Relacionamento cl√≠nica-usu√°rio
clinic_users {
  id: number,
  clinic_id: number,
  user_id: number,        -- ‚Üê FK para users
  role: string,
  permissions: array,
  is_professional: boolean
  -- ‚ùå SEM name, email
}

-- users: Dados pessoais dos usu√°rios  
users {
  id: number,
  name: string,           -- ‚Üê CAMPO NECESS√ÅRIO
  email: string,          -- ‚Üê CAMPO NECESS√ÅRIO
  created_at: timestamp
}
```

### ‚úÖ **Solu√ß√£o Implementada**

#### Abordagem: JOIN Manual via M√∫ltiplas Queries
```javascript
// ‚úÖ ENDPOINT CORRIGIDO: JOIN manual com tabela users
router.get('/clinic/:clinic_id/users/management', async (req, res) => {
  try {
    // 1. Buscar dados de clinic_users
    const clinicUsersQuery = `select=*&clinic_id=eq.${clinic_id}&is_active=eq.true`;
    const clinicUsers = await supabaseQuery(`clinic_users?${clinicUsersQuery}`);
    
    // 2. Para cada clinic_user, buscar dados do user
    const usersWithDetails = await Promise.all(
      clinicUsers.map(async (clinicUser) => {
        let userDetails = { name: 'Unknown User', email: '' };
        
        if (clinicUser.user_id) {
          const userQuery = `select=name,email&id=eq.${clinicUser.user_id}`;
          const users = await supabaseQuery(`users?${userQuery}`);
          if (users.length > 0) {
            userDetails = {
              name: users[0].name || 'Unknown User',
              email: users[0].email || ''
            };
          }
        }
        
        // 3. Combinar dados de ambas as tabelas
        return {
          ...clinicUser,
          name: userDetails.name,      // ‚Üê CAMPO ADICIONADO
          email: userDetails.email,    // ‚Üê CAMPO ADICIONADO
          permissions: clinicUser.permissions || []  // ‚Üê SANITIZA√á√ÉO
        };
      })
    );
    
    res.json(usersWithDetails);
  } catch (error) {
    res.status(500).json({ 
      error: 'Failed to get clinic users',
      details: error.message 
    });
  }
});
```

#### Sanitiza√ß√£o de Dados Null
```javascript
// ‚úÖ PADR√ÉO: Transformar null em arrays vazios
const sanitizedUser = {
  ...user,
  permissions: user.permissions || [],        // null ‚Üí []
  lunch_times: user.lunch_times || [],       // null ‚Üí []
  business_hours: user.business_hours || [], // null ‚Üí []
  services: user.services || [],             // null ‚Üí []
  payment_methods: user.payment_methods || [] // null ‚Üí []
};
```

### üß™ **Metodologia de Valida√ß√£o**

#### 1. **Teste Backend Direto**
```bash
# ‚úÖ VALIDAR: Endpoint retorna dados corretos
curl -s "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/clinic/1/users/management" | jq '.[0]'

# RESULTADO ESPERADO:
{
  "id": 11,
  "name": "Teste2",           # ‚Üê NOME PRESENTE
  "email": "teste2@gmail.com", # ‚Üê EMAIL PRESENTE
  "role": "usuario"
}
```

#### 2. **Teste Via Proxy Vercel**
```bash
# ‚úÖ VALIDAR: Proxy funciona end-to-end
curl -s "https://operabase.vercel.app/api/clinic/1/users/management" | jq '.[0].name'

# RESULTADO ESPERADO: "Teste2" (n√£o null)
```

#### 3. **Teste Frontend**
```bash
# ‚úÖ VALIDAR: Frontend n√£o apresenta erros de split()
npm run dev
# Acessar http://localhost:5174 e verificar console
# RESULTADO ESPERADO: Sem erros TypeError
```

### üìã **Padr√£o Replic√°vel para Outras APIs**

#### Template de Corre√ß√£o
```javascript
// üîÑ PADR√ÉO PARA OUTRAS APIs COM RELACIONAMENTOS

router.get('/api/endpoint-com-relacionamento', async (req, res) => {
  try {
    // 1. BUSCAR TABELA PRINCIPAL
    const mainQuery = `select=*&clinic_id=eq.${clinic_id}`;
    const mainRecords = await supabaseQuery(`main_table?${mainQuery}`);
    
    // 2. ENRIQUECER COM DADOS RELACIONADOS
    const enrichedRecords = await Promise.all(
      mainRecords.map(async (record) => {
        let relatedData = { name: 'Unknown', email: '' };
        
        if (record.related_id) {
          const relatedQuery = `select=name,email&id=eq.${record.related_id}`;
          const related = await supabaseQuery(`related_table?${relatedQuery}`);
          if (related.length > 0) {
            relatedData = {
              name: related[0].name || 'Unknown',
              email: related[0].email || ''
            };
          }
        }
        
        // 3. SANITIZAR CAMPOS NULL
        return {
          ...record,
          name: relatedData.name,
          email: relatedData.email,
          array_field: record.array_field || [],  // ‚Üê SEMPRE SANITIZAR
          permissions: record.permissions || []
        };
      })
    );
    
    res.json(enrichedRecords);
  } catch (error) {
    res.status(500).json({ 
      error: 'Failed to get records',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

### üéØ **Checklist de Valida√ß√£o para Futuras APIs**

#### ‚úÖ **Antes de Implementar**
- [ ] Identificar todas as tabelas envolvidas
- [ ] Mapear relacionamentos (FKs)
- [ ] Verificar quais campos s√£o necess√°rios no frontend
- [ ] Identificar campos que podem ser null

#### ‚úÖ **Durante Implementa√ß√£o**
- [ ] Implementar JOIN manual via m√∫ltiplas queries
- [ ] Sanitizar todos os campos array (null ‚Üí [])
- [ ] Adicionar tratamento de erro detalhado
- [ ] Incluir logs de debug

#### ‚úÖ **Valida√ß√£o P√≥s-Implementa√ß√£o**
- [ ] Testar endpoint direto no backend
- [ ] Testar via proxy Vercel
- [ ] Verificar no frontend (sem erros no console)
- [ ] Validar com dados reais da produ√ß√£o

### üöÄ **Resultados Comprovados**

#### Antes da Corre√ß√£o
```json
// ‚ùå DADOS INCOMPLETOS
{
  "id": 11,
  "name": null,     // ‚Üê Causava erro split()
  "email": null,
  "permissions": null // ‚Üê Causava erro map()
}
```

#### Depois da Corre√ß√£o
```json
// ‚úÖ DADOS COMPLETOS E SANITIZADOS
{
  "id": 11,
  "name": "Teste2",              // ‚Üê Nome real do usu√°rio
  "email": "teste2@gmail.com",   // ‚Üê Email real do usu√°rio
  "permissions": []              // ‚Üê Array vazio (n√£o null)
}
```

#### Impacto no Frontend
```typescript
// ‚úÖ AGORA FUNCIONA SEM ERROS
{user.name.split(' ').map(n => n[0]).join('').toUpperCase()}
//     ^^^^
//     "Teste2" ‚Üí ["Teste2"] ‚Üí ["T"] ‚Üí "T"
```

### üìö **Li√ß√µes Aprendidas**

#### 1. **Diagn√≥stico Sistem√°tico**
- Sempre come√ßar pelo erro no frontend
- Rastrear at√© a origem dos dados (API)
- Verificar estrutura das tabelas no banco

#### 2. **Padr√£o de Relacionamentos**
- Supabase REST API n√£o faz JOINs autom√°ticos
- Implementar JOIN manual via m√∫ltiplas queries
- Sempre incluir fallbacks para dados n√£o encontrados

#### 3. **Sanitiza√ß√£o Obrigat√≥ria**
- Frontend JavaScript n√£o tolera null em opera√ß√µes de array
- Sempre transformar null em [] para campos array
- Sempre transformar null em string vazia para campos string

#### 4. **Valida√ß√£o End-to-End**
- Testar backend direto
- Testar via proxy
- Testar no frontend
- Validar com dados reais

### üîÑ **Aplica√ß√£o para Pr√≥ximas Funcionalidades**

Este padr√£o deve ser aplicado para resolver:

1. **Conversations** ‚Üí JOIN com contacts para nomes
2. **Medical Records** ‚Üí JOIN com contacts e users
3. **Pipeline** ‚Üí JOIN com contacts e users
4. **Analytics** ‚Üí Agrega√ß√µes com JOINs
5. **Settings** ‚Üí Relacionamentos com users

**Cada funcionalidade seguir√° o mesmo padr√£o de diagn√≥stico, corre√ß√£o e valida√ß√£o estabelecido aqui.**

### Fluxo de Dados Completo

#### Arquitetura de Conectividade Final
```mermaid
graph LR
    A[Frontend Vercel HTTPS] --> B[Proxy Vercel HTTPS]
    B --> C[Backend AWS HTTP]
    C --> D[Supabase PostgreSQL]
    
    A --> E["/api/appointments"]
    E --> F["api/appointments.js"]
    F --> G["AWS Backend /api/appointments"]
    
    A --> H["/api/contacts"]
    H --> I["api/contacts.js"]  
    I --> J["AWS Backend /api/contacts"]
```

#### Teste de Conectividade Validado
```bash
# ‚úÖ Appointments funcionando
curl "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/appointments?clinic_id=1"
# Retorna: 90+ appointments

# ‚úÖ Contacts funcionando  
curl "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/contacts?clinic_id=1"
# Retorna: 35+ contacts

# ‚úÖ Health check funcionando
curl "http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/health"
# Retorna: {"status":"ok","timestamp":"2025-07-06T23:32:31.158Z"}
```

### GitHub Actions: Deploy Autom√°tico

#### Workflow Configurado
```yaml
# .github/workflows/deploy-aws.yml - Deploy autom√°tico para AWS
name: Deploy Backend to AWS

on:
  push:
    branches: [main]
    paths: ['server/**', 'package.json', 'package-lock.json', '.github/workflows/deploy-aws.yml']

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to AWS Elastic Beanstalk
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: operabase-backend-mvp
          environment_name: operabase-backend-mvp-env-1
          region: sa-east-1
          version_label: ${{ github.sha }}
          deployment_package: deployment.zip
```

#### Trigger Autom√°tico
- **Antes**: Apenas `server/production-server.js` disparava deploy
- **Depois**: Qualquer mudan√ßa em `server/**` dispara deploy autom√°tico
- **Resultado**: Mudan√ßas no sistema de domains agora fazem deploy corretamente

### Benef√≠cios da Solu√ß√£o

#### 1. Seguran√ßa Resolvida
- ‚úÖ **Mixed Content Error eliminado**
- ‚úÖ **HTTPS end-to-end** para o usu√°rio
- ‚úÖ **Certificados SSL** gerenciados automaticamente

#### 2. Performance Otimizada  
- ‚úÖ **Vercel Edge Network** para proxies
- ‚úÖ **Cache autom√°tico** de respostas est√°ticas
- ‚úÖ **Lat√™ncia reduzida** para usu√°rios globais

#### 3. Manutenibilidade
- ‚úÖ **Deploy independente** frontend/backend
- ‚úÖ **Rollback simples** de cada camada
- ‚úÖ **Monitoramento separado** de cada servi√ßo

#### 4. Escalabilidade
- ‚úÖ **Backend pode escalar** independentemente
- ‚úÖ **Frontend global** via Vercel CDN
- ‚úÖ **Load balancing** autom√°tico

### Monitoramento e Debug

#### Logs de Conectividade
```javascript
// Logging detalhado adicionado para debug
app.get('/api/contacts', async (req, res) => {
  try {
    log(`üîç CONTACTS DEBUG: Received request with clinic_id=${clinic_id}`);
    log(`üîç CONTACTS DEBUG: Executing Supabase query: contacts?${query}`);
    
    const contacts = await supabaseQuery(`contacts?${query}`);
    
    log(`üë• Retrieved ${contacts.length} contacts for clinic ${clinic_id}`);
    log(`üîç CONTACTS DEBUG: First contact sample:`, contacts[0]);
    
    res.json(contacts);
  } catch (error) {
    log(`‚ùå Error getting contacts: ${error.message}`);
    log(`‚ùå CONTACTS ERROR STACK: ${error.stack}`);
    res.status(500).json({ 
      error: 'Failed to get contacts',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

#### Health Check Expandido
```javascript
// Health check com verifica√ß√£o de conectividade
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'production',
    supabase_configured: !!SUPABASE_URL,
    service_role_configured: !!SUPABASE_SERVICE_ROLE_KEY,
    connectivity: {
      frontend_proxy: 'https://operabase.vercel.app/api/*',
      backend_direct: 'http://operabase-backend-mvp-env-1.sa-east-1.elasticbeanstalk.com/api/*',
      database: 'Supabase PostgreSQL'
    }
  });
});
```

## üèóÔ∏è Estrutura Geral

### Stack Tecnol√≥gico
- **Runtime**: Node.js 18.x
- **Framework**: Express.js 4.18.2
- **Database**: Supabase PostgreSQL
- **Cache**: Redis (ioredis)
- **ORM**: Drizzle ORM
- **Valida√ß√£o**: Zod schemas
- **Autentica√ß√£o**: Passport.js + Supabase Auth
- **Deploy**: AWS Elastic Beanstalk

### Arquitetura Base
```
server/
‚îú‚îÄ‚îÄ api/v1/                    # API versionada
‚îú‚îÄ‚îÄ domains/                   # Dom√≠nios funcionais (DDD)
‚îú‚îÄ‚îÄ shared/                    # Utilit√°rios compartilhados
‚îú‚îÄ‚îÄ middleware/                # Middleware customizado
‚îú‚îÄ‚îÄ infrastructure/            # Conex√µes externas
‚îú‚îÄ‚îÄ services/                  # Servi√ßos de neg√≥cio
‚îú‚îÄ‚îÄ testing/                   # Testes e load testing
‚îî‚îÄ‚îÄ mcp/                      # Integra√ß√£o N8N/MCP
```

## üéØ Dom√≠nios Funcionais (Domain-Driven Design)

### Estrutura de Dom√≠nio Padr√£o
Cada dom√≠nio segue o padr√£o **Controller ‚Üí Service ‚Üí Repository**:

```typescript
domains/
‚îú‚îÄ‚îÄ auth/                     # Autentica√ß√£o e autoriza√ß√£o
‚îú‚îÄ‚îÄ appointments/             # Agendamentos
‚îú‚îÄ‚îÄ contacts/                 # Contatos/Pacientes
‚îú‚îÄ‚îÄ calendar/                 # Sistema de calend√°rio
‚îú‚îÄ‚îÄ medical-records/          # Prontu√°rios m√©dicos
‚îú‚îÄ‚îÄ pipeline/                 # Pipeline de vendas
‚îú‚îÄ‚îÄ analytics/                # Analytics e relat√≥rios
‚îú‚îÄ‚îÄ settings/                 # Configura√ß√µes da cl√≠nica
‚îú‚îÄ‚îÄ ai-templates/             # Templates de IA
‚îú‚îÄ‚îÄ appointment-tags/         # Tags de agendamento
‚îú‚îÄ‚îÄ user-profile/             # Perfil do usu√°rio
‚îî‚îÄ‚îÄ livia/                    # Configura√ß√£o IA Livia
```

### Exemplo de Estrutura de Dom√≠nio
```typescript
// domains/appointments/
‚îú‚îÄ‚îÄ appointments.controller.ts  # Controller HTTP
‚îú‚îÄ‚îÄ appointments.service.ts     # L√≥gica de neg√≥cio
‚îú‚îÄ‚îÄ appointments.repository.ts  # Acesso a dados
‚îú‚îÄ‚îÄ appointments.routes.ts      # Defini√ß√£o de rotas
‚îú‚îÄ‚îÄ appointments.types.ts       # Tipos TypeScript
‚îú‚îÄ‚îÄ appointments.schema.ts      # Valida√ß√£o Zod
‚îî‚îÄ‚îÄ index.ts                   # Exports p√∫blicos
```

## üîê Sistema de Autentica√ß√£o

### Autentica√ß√£o H√≠brida
O sistema suporta **duas formas de autentica√ß√£o**:

1. **Session-based** (Passport.js)
2. **JWT Supabase** (Principal)

```typescript
// server/auth.ts - Middleware isAuthenticated
export const isAuthenticated = async (req: any, res: any, next: any) => {
  // BYPASS total para uploads
  if (req.originalUrl?.includes('/upload')) {
    return next();
  }
  
  // 1. Verificar session primeiro
  if (req.isAuthenticated && req.isAuthenticated()) {
    return next();
  }
  
  // 2. Verificar token Supabase
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.substring(7);
    
    // Validar token com Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token);
    if (!error && user) {
      // Buscar usu√°rio no banco local
      const dbUser = await storage.getUserByEmail(user.email);
      req.user = dbUser;
      return next();
    }
  }
  
  res.status(401).json({ error: "Acesso negado" });
};
```

### Controle de Acesso Multi-Tenant
```typescript
// Middleware hasClinicAccess
export const hasClinicAccess = (paramName: string = 'clinicId') => {
  return async (req: any, res: any, next: any) => {
    const user = req.user;
    const clinicId = parseInt(req.params[paramName]);
    
    // Super admin pode acessar tudo
    if (user.role === 'super_admin') {
      return next();
    }
    
    // Verificar acesso √† cl√≠nica
    const hasAccess = await storage.userHasClinicAccess(user.id, clinicId);
    if (!hasAccess) {
      return res.status(403).json({ error: "Acesso negado a esta cl√≠nica" });
    }
    
    next();
  };
};
```

## üåê Sistema de Roteamento

### Router Principal
```typescript
// server/api/v1/router.ts
export function createApiRouter(storage: any): Router {
  const apiRouter = Router();

  // Health check
  apiRouter.get('/health', (req, res) => {
    res.json({ 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      version: 'v1'
    });
  });

  // Dom√≠nios organizados em rotas modulares
  apiRouter.use('/', createAuthRoutes(storage));
  apiRouter.use('/', createAppointmentsRoutes(storage));
  apiRouter.use('/', createContactsRoutes(storage));
  apiRouter.use('/', createCalendarRoutes(storage));
  apiRouter.use('/', createMedicalRecordsRoutes(storage));
  apiRouter.use('/', createPipelineRoutes(storage));
  apiRouter.use('/', createAnalyticsRoutes(storage));
  apiRouter.use('/', createSettingsRoutes(storage));
  apiRouter.use('/', createAiTemplatesRoutes(storage));
  apiRouter.use('/', createAppointmentTagsRoutes(storage));
  apiRouter.use('/', createUserProfileRoutes(storage));
  apiRouter.use('/', createLiviaRoutes(storage));

  return apiRouter;
}
```

### Cadeia de Middleware
```typescript
// server/index.ts - Middleware chain aplicado a todas as rotas /api
app.use('/api', (req: any, res: any, next: any) => {
  // Skip middleware para uploads
  if (req.path.includes('/upload')) {
    return next();
  }
  
  // Cadeia de middleware em ordem espec√≠fica
  performanceTrackingMiddleware(req, res, () => {
    auditLoggingMiddleware(req, res, () => {
      cacheInterceptorMiddleware(req, res, () => {
        tenantIsolationMiddleware(req, res, () => {
          cacheInvalidationMiddleware(req, res, next);
        });
      });
    });
  });
});
```

## üíæ Sistema de Banco de Dados

### Conex√£o Supabase
```typescript
// server/db.ts
export const pool = new Pool({
  connectionString: process.env.SUPABASE_POOLER_URL,
  ssl: { rejectUnauthorized: false },
});

export const db = drizzle(pool, { schema });
```

### Storage Factory
```typescript
// server/storage-factory.ts
export function createStorage(): IStorage {
  let baseStorage: IStorage;
  
  if (process.env.DATABASE_URL) {
    baseStorage = new PostgreSQLStorage();
  } else {
    baseStorage = minimalStorage;
  }
  
  // Aplicar proxy de isolamento multi-tenant
  return new TenantAwareStorageProxy(baseStorage);
}
```

## üîÑ Sistema de Cache

### Configura√ß√£o Redis
```typescript
// server/infrastructure/redis-client.ts
class RedisClient {
  private client: Redis | null = null;
  
  constructor() {
    this.initializeClient();
  }
  
  private initializeClient() {
    try {
      this.client = new Redis({
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
        retryDelayOnFailover: 100,
        maxRetriesPerRequest: 3,
        lazyConnect: true
      });
    } catch (error) {
      console.warn('Redis connection failed, using memory fallback');
    }
  }
}
```

### Pol√≠ticas de Cache por Dom√≠nio
```typescript
// server/shared/cache-policies.ts
export class CachePolicies {
  static readonly CONTACTS: CachePolicy = {
    ttl: 300, // 5 minutos
    invalidateOn: ['create', 'update', 'delete', 'status_change'],
    strategy: 'cache-aside',
    priority: 'high',
    enabled: true
  };

  static readonly APPOINTMENTS: CachePolicy = {
    ttl: 120, // 2 minutos
    invalidateOn: ['create', 'update', 'delete', 'reschedule'],
    strategy: 'write-through',
    priority: 'high',
    enabled: true
  };

  static readonly MEDICAL_RECORDS: CachePolicy = {
    ttl: 1800, // 30 minutos
    invalidateOn: ['create', 'update'],
    strategy: 'read-through',
    priority: 'medium',
    enabled: true
  };
}
```

### Cache Middleware
```typescript
// server/shared/cache-interceptor.middleware.ts
export const cacheInterceptorMiddleware = async (req: any, res: any, next: any) => {
  const domain = extractDomainFromUrl(req.url);
  const policy = CACHE_POLICIES[domain];
  
  if (!policy?.enabled || req.method !== 'GET') {
    return next();
  }
  
  const cacheKey = generateCacheKey(req);
  const cachedData = await cacheService.get(cacheKey);
  
  if (cachedData) {
    return res.json(cachedData);
  }
  
  // Interceptar response para cache
  const originalSend = res.send;
  res.send = function(data: any) {
    if (res.statusCode === 200) {
      cacheService.set(cacheKey, data, policy.ttl);
    }
    return originalSend.call(this, data);
  };
  
  next();
};
```

## üè• Isolamento Multi-Tenant

### Tenant Context Provider
```typescript
// server/shared/tenant-context.provider.ts
class TenantContextProvider {
  private storage = new AsyncLocalStorage<TenantContext>();

  setContext(context: TenantContext): void {
    const currentContext = this.storage.getStore();
    if (currentContext) {
      Object.assign(currentContext, context);
    }
  }

  getClinicId(): number {
    const context = this.storage.getStore();
    if (!context?.clinicId) {
      throw new Error('No clinic context available');
    }
    return context.clinicId;
  }

  run<T>(context: TenantContext, callback: () => T): T {
    return this.storage.run(context, callback);
  }
}

export const tenantContext = new TenantContextProvider();
```

### Tenant Isolation Middleware
```typescript
// server/shared/tenant-isolation.middleware.ts
export const tenantIsolationMiddleware = (req: any, res: any, next: any) => {
  if (!req.user) {
    return next();
  }
  
  const clinicId = extractClinicIdFromRequest(req);
  
  if (clinicId) {
    tenantContext.run({
      clinicId,
      userId: req.user.id,
      userRole: req.user.role,
      isProfessional: req.user.role !== 'patient'
    }, next);
  } else {
    next();
  }
};
```

## üìä Sistema de Observabilidade

### Performance Monitor
```typescript
// server/shared/performance-monitor.service.ts
class PerformanceMonitorService {
  private metrics = {
    responseTime: { avg: 0, p95: 0, p99: 0, samples: [] },
    tenantMetrics: new Map(),
    apiEndpoints: new Map(),
    alerts: []
  };

  recordResponseTime(path: string, time: number, clinicId?: number) {
    // Atualizar m√©tricas globais
    this.metrics.responseTime.samples.push(time);
    
    // Atualizar m√©tricas por tenant
    if (clinicId) {
      const tenantMetric = this.metrics.tenantMetrics.get(clinicId) || {
        requestCount: 0,
        avgResponseTime: 0,
        errorRate: 0,
        lastActivity: Date.now()
      };
      
      tenantMetric.requestCount++;
      tenantMetric.avgResponseTime = 
        (tenantMetric.avgResponseTime + time) / 2;
      tenantMetric.lastActivity = Date.now();
      
      this.metrics.tenantMetrics.set(clinicId, tenantMetric);
    }
  }

  getHealthStatus() {
    const avgResponseTime = this.calculateAverage(this.metrics.responseTime.samples);
    
    return {
      status: avgResponseTime < 500 ? 'healthy' : 
              avgResponseTime < 1000 ? 'degraded' : 'unhealthy',
      timestamp: Date.now(),
      uptime: process.uptime(),
      issues: this.metrics.alerts.slice(-5)
    };
  }
}
```

### Structured Logger
```typescript
// server/shared/structured-logger.service.ts
export enum LogCategory {
  AUTH = 'auth',
  MEDICAL = 'medical',
  ADMIN = 'admin',
  API = 'api',
  SECURITY = 'security',
  PERFORMANCE = 'performance',
  CACHE = 'cache',
  AUDIT = 'audit'
}

export class StructuredLoggerService {
  private logQueue: LogEntry[] = [];
  private readonly maxQueueSize = 200;
  private readonly flushIntervalMs = 3000;

  info(category: LogCategory, action: string, metadata: any) {
    this.addToQueue('INFO', category, action, metadata);
  }

  error(category: LogCategory, action: string, metadata: any) {
    this.addToQueue('ERROR', category, action, metadata);
  }

  private addToQueue(level: string, category: LogCategory, action: string, metadata: any) {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      category,
      action,
      metadata,
      clinic_id: tenantContext.hasContext() ? tenantContext.getClinicId() : null,
      user_id: metadata.user_id || null
    };

    this.logQueue.push(entry);
    
    if (this.logQueue.length >= this.maxQueueSize) {
      this.flushLogs();
    }
  }
}
```

## üì° Sistema de Comunica√ß√£o

### Integra√ß√£o WhatsApp (Evolution API)
```typescript
// server/services/evolution-message.service.ts
export class EvolutionMessageService {
  private baseUrl: string;
  private apiKey: string;

  async sendTextMessage(conversationId: number, content: string) {
    const conversation = await this.getConversation(conversationId);
    const whatsappNumber = await this.getWhatsAppNumber(conversation.clinic_id);
    
    const response = await fetch(`${this.baseUrl}/message/sendText/${whatsappNumber.instance_name}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': this.apiKey
      },
      body: JSON.stringify({
        number: conversation.contact.phone,
        text: content
      })
    });

    return await response.json();
  }

  async sendMediaMessage(conversationId: number, mediaUrl: string, caption?: string) {
    // Implementa√ß√£o similar para m√≠dia
  }
}
```

### Upload de Arquivos
```typescript
// server/services/conversation-upload.service.ts
export class ConversationUploadService {
  async uploadFile(options: {
    conversationId: string;
    file: Buffer;
    filename: string;
    mimeType: string;
    sendToWhatsApp: boolean;
    senderType: 'professional' | 'patient';
    caption?: string;
  }) {
    // 1. Upload para Supabase Storage
    const storageResult = await this.uploadToSupabaseStorage(options);
    
    // 2. Criar registro de mensagem
    const message = await this.createMessage(options, storageResult);
    
    // 3. Criar attachment
    const attachment = await this.createAttachment(message.id, storageResult);
    
    // 4. Enviar para WhatsApp (se solicitado)
    let whatsappResult = null;
    if (options.sendToWhatsApp) {
      whatsappResult = await this.sendToWhatsApp(options, storageResult);
    }
    
    return {
      success: true,
      message,
      attachment,
      storageResult,
      whatsappResult
    };
  }
}
```

## üß™ Sistema de Testes

### Load Testing
```typescript
// server/testing/load-testing.service.ts
export class LoadTestingService {
  async runLoadTest(config: LoadTestConfig): Promise<LoadTestResult> {
    const scenarios = [
      this.createAppointmentScenario(),
      this.createContactScenario(),
      this.createConversationScenario()
    ];

    const results = await Promise.all(
      scenarios.map(scenario => this.executeScenario(scenario, config))
    );

    return this.aggregateResults(results);
  }

  private async executeScenario(scenario: TestScenario, config: LoadTestConfig) {
    const promises = [];
    
    for (let i = 0; i < config.concurrentUsers; i++) {
      promises.push(this.simulateUser(scenario, config.duration));
    }
    
    return await Promise.all(promises);
  }
}
```

### Resource Monitor
```typescript
// server/testing/resource-monitor.service.ts
export class ResourceMonitorService extends EventEmitter {
  private intervalId: NodeJS.Timeout | null = null;

  startMonitoring(intervalMs: number = 5000) {
    this.intervalId = setInterval(() => {
      const snapshot = this.captureSnapshot();
      this.emit('snapshot', snapshot);
      
      if (this.detectResourceStress(snapshot)) {
        this.emit('stress', snapshot);
      }
    }, intervalMs);
  }

  private captureSnapshot(): ResourceSnapshot {
    return {
      timestamp: new Date().toISOString(),
      system: {
        cpu_usage: os.loadavg()[0],
        memory_usage: process.memoryUsage().heapUsed,
        free_memory: os.freemem(),
        load_average: os.loadavg(),
        uptime: os.uptime()
      },
      database: this.getDatabaseMetrics(),
      cache: this.getCacheMetrics(),
      application: this.getApplicationMetrics(),
      network: this.getNetworkMetrics()
    };
  }
}
```

## üöÄ Deploy e Configura√ß√£o

### Ambiente de Produ√ß√£o (AWS)
```bash
# Vari√°veis de ambiente essenciais
NODE_ENV=production
PORT=5000

# Supabase
SUPABASE_URL=https://lkwrevhxugaxfpwiktdy.supabase.co
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
SUPABASE_POOLER_URL=postgresql://postgres.lkwrevhxugaxfpwiktdy...

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# Session
SESSION_SECRET=your-session-secret

# Evolution API (WhatsApp)
EVOLUTION_API_URL=https://your-evolution-instance.com
EVOLUTION_API_KEY=your-api-key
```

### Health Checks
```typescript
// Endpoint de health check completo
app.get('/health', async (req, res) => {
  const health = {
    status: 'ok',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
    version: 'v1.0',
    services: {
      database: await testDatabaseConnection(),
      cache: await testCacheConnection(),
      storage: await testStorageConnection()
    },
    metrics: {
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      cpu: os.loadavg()
    }
  };

  const allServicesHealthy = Object.values(health.services)
    .every(service => service.status === 'healthy');

  res.status(allServicesHealthy ? 200 : 503).json(health);
});
```

## ‚úÖ Funcionalidades Testadas e Funcionais

### üåê Conectividade Frontend-Backend
- ‚úÖ **Mixed Content Error resolvido** via proxy HTTPS
- ‚úÖ **Proxy Vercel funcionando** para todas as rotas API
- ‚úÖ **Appointments endpoint** retornando 90+ registros
- ‚úÖ **Contacts endpoint** retornando 35+ contatos
- ‚úÖ **Production server corrigido** (query `created_at` removida)
- ‚úÖ **GitHub Actions deploy** autom√°tico para mudan√ßas em `server/**`
- ‚úÖ **Sistema h√≠brido** Vercel (frontend) + AWS (backend)
- ‚úÖ **HTTPS end-to-end** para seguran√ßa completa

### üîê Autentica√ß√£o
- ‚úÖ Login/Logout com Passport.js
- ‚úÖ Autentica√ß√£o JWT Supabase
- ‚úÖ Middleware de autoriza√ß√£o
- ‚úÖ Controle de acesso multi-tenant
- ‚úÖ Session management

### üìä API Core
- ‚úÖ Health check endpoint
- ‚úÖ CORS configurado para Vercel
- ‚úÖ Middleware chain completo
- ‚úÖ Response padronizado
- ‚úÖ Error handling global

### üíæ Banco de Dados
- ‚úÖ Conex√£o Supabase PostgreSQL
- ‚úÖ Drizzle ORM funcionando
- ‚úÖ Schemas validados
- ‚úÖ Queries otimizadas
- ‚úÖ Connection pooling

### üîÑ Cache System
- ‚úÖ Redis client configurado
- ‚úÖ Cache policies por dom√≠nio
- ‚úÖ Cache invalidation
- ‚úÖ Fallback para memory cache
- ‚úÖ Performance metrics

### üì± Comunica√ß√£o
- ‚úÖ Sistema de conversas
- ‚úÖ Upload de arquivos
- ‚úÖ Integra√ß√£o WhatsApp (Evolution API)
- ‚úÖ Supabase Storage
- ‚úÖ Mensagens de voz

### üìà Observabilidade
- ‚úÖ Performance monitoring
- ‚úÖ Structured logging
- ‚úÖ Resource monitoring
- ‚úÖ Load testing framework
- ‚úÖ Health metrics

### üè• Multi-Tenant
- ‚úÖ Isolamento por cl√≠nica
- ‚úÖ Tenant context provider
- ‚úÖ Data segregation
- ‚úÖ Security policies
- ‚úÖ Audit logging

## üõ°Ô∏è Regras e Crit√©rios de Seguran√ßa

### 1. Isolamento Multi-Tenant
- **OBRIGAT√ìRIO**: Todas as queries devem incluir `clinic_id`
- **VALIDA√á√ÉO**: Middleware verifica acesso √† cl√≠nica
- **AUDITORIA**: Logs de todas as opera√ß√µes por tenant
- **CONTEXTO**: AsyncLocalStorage para isolamento de thread

### 2. Autentica√ß√£o e Autoriza√ß√£o
- **BYPASS**: Apenas uploads t√™m bypass de auth
- **DUPLA VALIDA√á√ÉO**: Session + JWT Supabase
- **ROLES**: admin, professional, patient, super_admin
- **TIMEOUT**: Sessions expiram em 7 dias

### 3. Valida√ß√£o de Dados
- **ZOD SCHEMAS**: Valida√ß√£o obrigat√≥ria em todos os endpoints
- **SANITIZA√á√ÉO**: Dados m√©dicos s√£o sanitizados em logs
- **TYPE SAFETY**: TypeScript strict mode
- **SQL INJECTION**: Drizzle ORM previne automaticamente

### 4. Performance e Cache
- **CACHE TTL**: Configurado por dom√≠nio (2min-2h)
- **INVALIDA√á√ÉO**: Autom√°tica em CUD operations
- **MONITORING**: Response time < 500ms target
- **LOAD TESTING**: Suporte a 1000+ usu√°rios concorrentes

### 5. Logs e Auditoria
- **STRUCTURED LOGS**: JSON format com categorias
- **RETENTION**: Logs locais + eventual cloud storage
- **MEDICAL COMPLIANCE**: LGPD/HIPAA compliance
- **REAL-TIME**: Flush a cada 3 segundos

### 6. Error Handling
- **GRACEFUL DEGRADATION**: Sistema continua funcionando com falhas parciais
- **CIRCUIT BREAKER**: Redis fallback para memory
- **RETRY LOGIC**: 3 tentativas para opera√ß√µes cr√≠ticas
- **USER FRIENDLY**: Mensagens de erro em portugu√™s

## üìù Padr√µes de Desenvolvimento

### 1. Estrutura de C√≥digo
```typescript
// Padr√£o Controller
export class AppointmentsController {
  constructor(private service: AppointmentsService) {}
  
  async getAppointments(req: Request, res: Response) {
    try {
      const result = await this.service.getAppointments(req.params.clinicId);
      res.json(createSuccessResponse(result));
    } catch (error) {
      res.status(500).json(createErrorResponse(error.message));
    }
  }
}

// Padr√£o Service
export class AppointmentsService {
  constructor(private repository: AppointmentsRepository) {}
  
  async getAppointments(clinicId: number) {
    return await this.repository.findByClinic(clinicId);
  }
}

// Padr√£o Repository
export class AppointmentsRepository {
  async findByClinic(clinicId: number) {
    return await db.select().from(appointments).where(eq(appointments.clinic_id, clinicId));
  }
}
```

### 2. Tratamento de Erros
```typescript
// Error classes customizadas
export class TenantIsolationError extends Error {
  constructor(attemptedClinicId: number, userClinicId: number) {
    super('Tenant isolation violation');
    this.name = 'TenantIsolationError';
    this.context = { attemptedClinicId, userClinicId };
  }
}

// Middleware de error handling
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  structuredLogger.error(LogCategory.API, 'unhandled_error', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    user_id: req.user?.id,
    clinic_id: tenantContext.hasContext() ? tenantContext.getClinicId() : null
  });

  if (error instanceof TenantIsolationError) {
    return res.status(403).json(createTenantIsolationErrorResponse(
      error.context.attemptedClinicId,
      error.context.userClinicId
    ));
  }

  res.status(500).json(createErrorResponse('Internal server error'));
};
```

### 3. Valida√ß√£o com Zod
```typescript
// Schema de valida√ß√£o
export const createAppointmentSchema = z.object({
  contact_id: z.number().positive(),
  professional_id: z.number().positive(),
  datetime: z.string().datetime(),
  duration: z.number().min(15).max(480),
  type: z.enum(['consultation', 'exam', 'procedure']),
  notes: z.string().optional()
});

// Middleware de valida√ß√£o
export const validateRequest = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json(createValidationErrorResponse(
          'Validation failed',
          error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message,
            code: err.code,
            value: err.input
          }))
        ));
      }
      next(error);
    }
  };
};
```

## üîß Configura√ß√£o de Desenvolvimento

### Pr√©-requisitos
```bash
# Node.js 18.x
node --version  # v18.x.x

# Depend√™ncias globais
npm install -g typescript ts-node

# Vari√°veis de ambiente (.env)
cp .env.example .env
```

### Comandos de Desenvolvimento
```bash
# Instalar depend√™ncias
npm install

# Desenvolvimento (frontend)
npm run dev

# Build para produ√ß√£o
npm run build

# Servidor de produ√ß√£o
npm start

# Testes
npm test
```

### Estrutura de Arquivos
```
server/
‚îú‚îÄ‚îÄ index.ts                  # Entry point principal
‚îú‚îÄ‚îÄ production-server.js      # Servidor de produ√ß√£o (Node.js puro)
‚îú‚îÄ‚îÄ auth.ts                   # Sistema de autentica√ß√£o
‚îú‚îÄ‚îÄ storage.ts               # Interface de storage
‚îú‚îÄ‚îÄ postgres-storage.ts      # Implementa√ß√£o PostgreSQL
‚îú‚îÄ‚îÄ db.ts                    # Conex√£o Drizzle
‚îî‚îÄ‚îÄ supabase.ts             # Cliente Supabase
```

---

## üìû Suporte e Contato

Para d√∫vidas sobre a arquitetura ou implementa√ß√£o:
- **Documenta√ß√£o**: `/docs` directory
- **Logs**: Verificar structured logs
- **Health Check**: `GET /health`
- **Metrics**: `GET /api/metrics` (autenticado)

---

*Documenta√ß√£o atualizada em: Janeiro 2025*
*Vers√£o: v1.0*
*Status: ‚úÖ Produ√ß√£o* 